# ITSM Project

## Технологии

- **Next.js 15** — SSR/SSG, маршрутизация, API-роуты
- **Prisma** — ORM для работы с PostgreSQL
- **PostgreSQL** — основная база данных
- **Tailwind CSS** — стилизация UI
- **Zod** — валидация данных и форм
- **Radix/ShadCN** — UI-компоненты и уведомления
- **TypeScript** — типизация всего кода
- **LDAP** — поддержка корпоративной авторизации (опционально)

## Описание

Веб-приложение для управления инцидентами, запросами, изменениями и пользователями на базе Next.js 15, Prisma, PostgreSQL.

---

## 1. Структура проекта и папок

### **app/**

- **Назначение:** Главная точка входа для страниц и API-роутов (Next.js App Router).
- **Страницы**: Каждая папка — отдельный маршрут. Например, `app/incidents/` содержит:
  - `page.tsx` — список инцидентов (серверный компонент, получает данные через Prisma).
  - `new/page.tsx` — форма создания (клиентский компонент, использует useState/useEffect, отправляет данные через fetch).
  - `[id]/page.tsx` — просмотр/редактирование (динамический роут, получает id через params).
- **API**: Внутри `app/api/` — подпапки для каждой сущности (users, incidents, requests и т.д.), в каждой подпапке — отдельные файлы для CRUD, смены статуса, назначения и т.д.
- **Особенности реализации**:
  - Используется file-based routing Next.js: структура папок = структура URL.
  - Для динамических роутов используются квадратные скобки: `[id]/page.tsx`.
  - Для вложенных действий (например, смена статуса) — подпапки: `status/route.ts`.

### **components/**

- **Назначение:** Все переиспользуемые UI-компоненты.
- **Структура:**
  - **ui/** — атомарные компоненты (Button, Input, Card, Select, Alert, Checkbox и др.), написаны с использованием Tailwind, forwardRef, поддерживают className для кастомизации.
  - **header.tsx, sidebar.tsx** — layout-компоненты.
  - **notification-bell.tsx, notification-center.tsx** — работа с уведомлениями.
  - **user-form.tsx, user-profile-card.tsx** — формы и карточки пользователя.
- **Паттерны:**
  - Все компоненты максимально атомарны, не содержат бизнес-логики.
  - Для сложных форм используются кастомные хуки и схемы валидации (zod).
  - Для стилизации — Tailwind + возможность расширения через className.

### **hooks/**

- **Назначение:** Кастомные React-хуки для повторного использования логики.
- **Примеры:**
  - **use-user.tsx** — загрузка, обновление пользователя, хранит состояния loading/error/user, использует useCallback для мемоизации.
  - **use-toast.ts** — глобальные уведомления, реализует паттерн pub/sub, хранит очередь уведомлений, позволяет вызывать toast из любого места.
  - **use-mobile.tsx** — определяет, мобильное ли устройство, для адаптивного UI.
- **Реализация:** Все хуки используют только React API, не зависят от внешних библиотек (кроме zod для валидации).

### **lib/**

- **Назначение:** Бизнес-логика, работа с БД, валидация, вспомогательные функции.
- **Структура:**
  - **actions/** — отдельный файл для каждой сущности (users, incidents, requests и т.д.), реализует CRUD, дополнительные действия (смена статуса, назначение и т.д.).
    - Пример: `createIncident(formData, userId)` — получает данные из формы, валидирует, создает запись через Prisma, возвращает результат.
  - **auth.ts** — функции для аутентификации (getCurrentUser, login, logout), используют JWT, хранят токен в cookie.
  - **prisma.ts** — инициализация Prisma Client, singleton-паттерн для предотвращения повторного создания клиента.
  - **utils.ts** — вспомогательные функции (например, fetchWithTimeout — обертка над fetch с таймаутом и обработкой ошибок).
  - **validation/** — схемы валидации (zod), для каждого типа данных отдельная схема (user, incident и т.д.).
- **Паттерны:**
  - Вся бизнес-логика вынесена из компонентов, чтобы облегчить тестирование и повторное использование.
  - Для валидации всегда используется zod, ошибки пробрасываются наверх для отображения пользователю.

### **prisma/**

- **Назначение:** Работа с базой данных.
- **schema.prisma** — описание моделей, связей, индексов.
- **migrations/** — миграции, создаются автоматически через Prisma CLI.
- **seed.ts** — сидирование тестовыми данными (создание пользователей, инцидентов и т.д.).
- **Паттерны:**
  - Все связи между сущностями явно описаны (relation).
  - Для каждого изменения структуры БД — отдельная миграция.

### **public/**

- **Назначение:** Статические файлы (картинки, favicon, загружаемые файлы).
- **Особенности:** Все, что лежит в public, доступно по прямому URL.

### **styles/**

- **Назначение:** Tailwind CSS, глобальные стили.
- **globals.css** — базовые стили, кастомизация Tailwind.
- **tailwind.config.ts** — настройка тем, кастомных цветов, брейкпоинтов.

### **scripts/**

- **Назначение:** SQL-скрипты для инициализации и наполнения БД.
- **Использование:** Обычно запускаются вручную или через npm-скрипты.

---

## 2. Роуты: реализация, паттерны, обработка ошибок

### **Страницы (app/)**

- **CRUD:** Для каждой сущности реализованы страницы списка, создания, просмотра/редактирования.
- **Фильтрация:** Используется query-параметры или фильтрация на сервере через Prisma.
- **Авторизация:** Проверка пользователя через getCurrentUser (lib/auth.ts), если не авторизован — редирект на /login.
- **Обработка ошибок:** Все асинхронные операции обернуты в try/catch, ошибки отображаются пользователю через UI (toast, alert).

### **API (app/api/)**

- **REST:** Каждый endpoint реализует отдельное действие (GET, POST, PATCH, DELETE).
- **Структура:** Для сложных действий (смена статуса, назначение) — отдельные подпапки.
- **Валидация:** Все входные данные валидируются через zod (lib/validation).
- **Ответы:** Всегда возвращается JSON с полем success/error, подробное сообщение об ошибке.
- **Авторизация:** Проверка токена пользователя, если нет — 401.

#### Дополнительные endpoints

- **db-status/route.ts** — Проверка состояния БД, размер, время последнего бэкапа. Метод: GET. Возвращает статус, размер, lastBackup.
- **help/route.ts** — Получение и обновление справочного текста для пользователей. GET — получить текст, POST (только ADMIN) — обновить.
- **ldap-test/route.ts** — Тест подключения к LDAP/AD. POST: host, port, user, password, ssl, baseDN. Возвращает success/error.
- **logout/route.ts** — Выход пользователя, удаление сессии и cookie. POST. Возвращает success.
- **search/route.ts** — Глобальный поиск по ИТ-ресурсам, рабочим станциям, пользователям, инцидентам, статьям. GET с query-параметром q. Возвращает массив результатов разных типов.
- **settings/route.ts** — Получение и обновление системных настроек. GET — все настройки, POST — обновление (только для ADMIN). Использует upsert по ключу.
- **Пример реализации:**

  ```ts
  // app/api/incidents/route.ts
  export async function POST(req) {
    const data = await req.json();
    const parsed = incidentSchema.safeParse(data);
    if (!parsed.success) return Response.json({ error: parsed.error }, { status: 400 });
    // ... создание инцидента
    return Response.json({ success: true });
  }
  ```

---

## 3. Компоненты: паттерны, стилизация, взаимодействие

- **Атомарность:** Каждый компонент делает только одну вещь (Button, Input, Card и т.д.).
- **Переиспользование:** Все компоненты поддерживают className, можно расширять стили.
- **Формы:** Для сложных форм используется zod для валидации, ошибки отображаются рядом с полем.
- **Стилизация:** Tailwind, поддержка тем (light/dark), кастомизация через tailwind.config.ts.
- **Интерактивность:** Для интерактивных элементов (кнопки, чекбоксы) используются forwardRef, чтобы поддерживать работу с формами и accessibility.
- **Пример:**

  ```tsx
  <form onSubmit={handleSubmit}>
    <Input value={form.email} onChange={...} />
    <Button type="submit">Сохранить</Button>
  </form>
  ```

---

## 4. Хуки: назначение, интеграция, примеры

- **useUser:** Получение и обновление пользователя, хранит состояния, используется в профиле, списках, формах.
- **useToast:** Глобальные уведомления, можно вызвать из любого места, поддерживает очередь, автоудаление.
- **useMobile:** Определяет мобильное устройство, позволяет адаптировать UI.
- **Интеграция:** Все хуки импортируются и используются в компонентах, не требуют дополнительной настройки.

---

## 5. Бизнес-логика и утилиты

- **actions:** Для каждой сущности отдельный файл, реализует все действия (CRUD, смена статуса, назначение и т.д.).
- **Валидация:** Всегда через zod, ошибки пробрасываются наверх.
- **Работа с БД:** Через Prisma, все запросы асинхронные, обернуты в try/catch.
- **Обработка ошибок:** Все ошибки логируются, пользователю возвращается понятное сообщение.
- **Пример:**

  ```ts
  export async function createRequest(formData, userId) {
    // ... валидация
    try {
      await prisma.request.create({ ... });
      return { success: true };
    } catch (e) {
      return { error: 'Ошибка создания запроса' };
    }
  }
  ```

---

## 6. Работа с БД

- **Миграции:** Через Prisma CLI (`npx prisma migrate dev`), каждая миграция — отдельная папка.
- **Сиды:** seed.ts — наполнение тестовыми данными, можно запускать через `npx prisma db seed`.
- **Модели:** Описаны в schema.prisma, поддерживают связи (relation), индексы, уникальные поля.
- **Пример модели:**

  ```prisma
  model Incident {
    id        String   @id @default(uuid())
    title     String
    status    String
    createdAt DateTime @default(now())
    // ...
  }
  ```

---

## 7. Стилизация

- **Tailwind:** Используется для всех компонентов, кастомизация через tailwind.config.ts.
- **Темы:** Поддержка светлой/тёмной темы, переключение через UI.
- **Глобальные стили:** В файле styles/globals.css.

---

## 8. Тестирование и расширение

- **Добавление новых фич:** Следуйте паттернам — новая сущность = новая папка в app, actions, API, компоненты, схема в БД.
- **Тестирование:** Для бизнес-логики можно писать unit-тесты (например, через jest).
- **CI/CD:** Можно настроить через GitHub Actions — запускать тесты, миграции, деплой.

---

## 9. Примеры кода и best practices

- **Асинхронные операции:**

  ```ts
  try {
    const res = await fetch(...);
    if (!res.ok) throw new Error('Ошибка');
    const data = await res.json();
  } catch (e) {
    // обработка ошибки
  }
  ```

- **Валидация через zod:**

  ```ts
  const schema = z.object({ ... });
  const parsed = schema.safeParse(data);
  if (!parsed.success) return { error: parsed.error };
  ```

- **Работа с формами:**

  ```tsx
  <form onSubmit={handleSubmit}>
    <Input ... />
    <Button ... />
  </form>
  ```

---

## 10. Шаблоны заявок и инцидентов

- **Назначение:** Позволяют создавать и редактировать шаблоны для инцидентов и запросов, чтобы стандартизировать структуру форм для пользователей.
- **Типы шаблонов:**
  - Тип указывается как "Запрос" или "Инцидент" (отображается по-русски, в БД хранится REQUEST/INCIDENT).
- **UI/UX:**
  - Создание и редактирование шаблона происходит в overlay-форме (модальное окно).
  - Используется двухшаговый wizard: сначала основные параметры (тип, название, описание, активность), затем структура полей.
  - Для структуры полей поддерживается drag&drop (можно менять порядок полей мышкой).
  - Можно добавлять, удалять, редактировать поля разных типов (text, select, checkbox и др.).
  - Для select-полей поддерживается ввод вариантов через запятую.
  - Есть превью формы по шаблону прямо в редакторе.
  - После сохранения шаблон появляется в общем списке.
- **Экспорт/импорт:**
  - Можно экспортировать все шаблоны в JSON-файл и импортировать обратно через UI.
- **Best practices:**
  - Для новых типов заявок/инцидентов создавайте отдельные шаблоны.
  - Используйте drag&drop для удобной сортировки полей.
  - Для обязательных полей отмечайте чекбокс "Обязательное".
  - Для select всегда указывайте варианты через запятую.
- **Рекомендации по расширению:**
  - Для новых типов форм добавляйте новые значения в массив типов.
  - Для новых типов полей расширяйте FIELD_TYPES и логику FieldEditor.

---

## Как добавить новую сущность (пример)

1. В папке `app/` создаёте папку с именем сущности (например, `assets/`).
2. Внутри создаёте:
   - `page.tsx` — список.
   - `new/page.tsx` — создание.
   - `[id]/page.tsx` — детали.
3. В `app/api/` создаёте аналогичную структуру для API.
4. В `lib/actions/` добавляете файл с бизнес-логикой.
5. В `components/` — формы, карточки, списки для UI.
6. В `prisma/schema.prisma` — добавляете модель, делаете миграцию.

---

## Рекомендации для нового разработчика

- Всегда используйте camelCase.
- Разбивайте большие компоненты на мелкие.
- Все асинхронные операции — через try/catch.
- Для валидации используйте zod.
- Для fetch используйте обработку ошибок и таймауты (см. lib/utils.ts).
- Для новых API-роутов используйте REST-структуру (CRUD + отдельные endpoints для статусов/приоритетов).
- Для UI используйте компоненты из `components/ui/` и переиспользуйте существующие решения.

---

## Запуск проекта

1. Установите зависимости:

   ```bash
   npm install
   ```

2. Настройте переменные окружения в `.env` (см. пример ниже).
3. Примените миграции:

   ```bash
   npx prisma migrate dev
   ```

4. Запустите dev-сервер:

   ```bash
   npm run dev
   ```

### Полный пример .env

Обязательные:

```env
DATABASE_URL=postgresql://user:password@localhost:5432/dbname
JWT_SECRET=your-secret-key
NODE_ENV=development
```

Рекомендуемые (безопасность и сеть):

```env
# Список разрешённых Origin через запятую (для CSRF-защиты). Пример: http://localhost:3000,http://127.0.0.1:3000
ALLOWED_ORIGINS=

# Опционально: публичный адрес dev-сервера для HMR за прокси/в сети
NEXT_PUBLIC_WS_URL=
```

LDAP (если используется вход по домену; значения обычно хранятся в БД `systemSettings`, но ниже — быстрый чек-лист ключей):

```Интерфейс
# ldapHost, ldapPort, ldapSSL, ldapUserDN, ldapUserPassword,
# ldapBaseDN, ldapAttrLogin, ldapAttrEmail, ldapAttrFirstName, ldapAttrLastName, ldapDomain
# Эти ключи задаются через интерфейс «Настройки» и сохраняются в БД.
```

---

## Пример настройки Nginx для HTTPS

```nginx
server {
    listen 443 ssl;
    server_name your-domain.com;

    ssl_certificate     /etc/letsencrypt/live/your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;
    ssl_protocols       TLSv1.2 TLSv1.3;
    ssl_ciphers         HIGH:!aNULL:!MD5;

    location / {
        proxy_pass         http://127.0.0.1:3000;
        proxy_set_header   Host $host;
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto $scheme;
        proxy_set_header   X-Forwarded-Host $host;
        proxy_set_header   X-Forwarded-Port $server_port;
        proxy_http_version 1.1;
        proxy_set_header   Upgrade $http_upgrade;
        proxy_set_header   Connection $connection_upgrade;
        proxy_read_timeout 3600;
        proxy_buffering    off; # Для SSE/stream
    }

    # Для Let's Encrypt challenge (если нужно)
    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }
}

server {
    listen 80;
    server_name your-domain.com;
    return 301 https://$host$request_uri;
}
```

**Примечания:**

- Сертификаты можно получить через [Let's Encrypt](https://letsencrypt.org/).
- Для production убедитесь, что cookie auth-token помечен как secure.
- Для SSE (stream уведомлений) обязательно proxy_buffering off.
- Пробрасывайте все X-Forwarded-* заголовки для корректной работы авторизации и логирования.
- Для WebSocket/SSE proxy_http_version 1.1 и Upgrade/Connection обязательны.

---

## Документация

- [Next.js](https://nextjs.org/docs)
- [Prisma](https://www.prisma.io/docs)
- [Zod](https://zod.dev/)

---

## Production и безопасность

- Cookie `auth-token` помечается как `secure` в production; за прокси/HTTPS убедитесь, что фронт доступен по HTTPS.
- Глобальная CSRF‑проверка: в middleware для небезопасных методов сверяется `Origin` с `Host` и `ALLOWED_ORIGINS`.
- Rate limiting: в проекте используется простой in‑memory лимитер (см. `lib/utils.ts:isRateLimited`). Для production рекомендуется Redis.
- Загружаемые файлы сохраняются в `public/uploads`. Папка исключена из git и должна быть доступна на запись пользователем процесса Node.

## Файлы и загрузки

- Инциденты: загрузка вложений при создании и обновлении (`app/api/incidents/route.ts`, `app/api/incidents/update/route.ts`).
- Запросы: загрузка файла согласования (`app/api/requests/route.ts`, `app/api/requests/update/route.ts`).
- Путь хранения: `public/uploads/<имя_файла>`, в БД сохраняются относительные пути вида `/uploads/...`.

## Роли и бизнес‑правила

- Роли: `ADMIN`, `TECHNICIAN`, `MANAGER`, `USER`.
- При создании инцидента пользователем с ролью `USER` приоритет принудительно `LOW`, исполнитель не назначается — дальнейшие изменения делает администратор.

## Отчёты и знания

- Убраны мок‑данные SLA на странице отчётов.
- На странице базы знаний статистика рассчитывается по данным БД (кол-во статей, просмотры, средний рейтинг, активные авторы за месяц).

## Уведомления (toast) и подтверждения

- Единая система уведомлений на базе ShadCN/Radix (`components/ui/toast*`, `components/ui/toaster`). Максимум 3 одновременных уведомления.
- Все подтверждения действий — через модальные `AlertDialog` (см. `components/ui/confirm-dialog.tsx`).

## Поток уведомлений (SSE)

- Endpoint: `GET /api/notifications/stream` — серверные события. За прокси включите поддержку keep‑alive и не буферизуйте ответ.

## Сборка и деплой

```bash
npm run build
npm run start
```

- За прокси (Nginx/Apache) пробрасывайте заголовки `X-Forwarded-*`.
- Если в dev при доступе по IP возникают 403 для `/_next` или `__nextjs_font`, убедитесь, что middleware не матчится на эти пути и в `next.config.mjs` включены нужные заголовки для dev.

## Известные нюансы / троблшутинг

- Ошибка сборки с `dtrace-provider`: в `next.config.mjs` настроен alias `dtrace-provider: false` для клиента. Пересоберите после `rm -rf node_modules .next && npm i` при необходимости.
- "Rendered fewer hooks than expected": убедитесь, что вызовы хуков не зависят от условных возвратов (см. фикс в `app/requests/RequestsListClient.tsx`).
- При быстром редиректе тосты могут быть не видны — в списках реализованы локальные обновления состояния без `window.location.reload()`.

## Скрипты

- `npm run dev` — локальная разработка
- `npm run build` — сборка
- `npm run start` — запуск production
- `npm run studio` — Prisma Studio
- `npm run seed` — сидирование данных (`prisma/seed.ts`)

Если есть вопросы — пишите в issues!

---

## Запуск через Docker (опционально)

1. Соберите контейнер:

   ```bash
   docker build -t itsm-app .
   ```

2. Запустите контейнер:

   ```bash
   docker run --env-file .env -p 3000:3000 itsm-app
   ```

3. Для работы с БД используйте отдельный контейнер PostgreSQL или внешний сервер.

---

## Контакты

- Разработчик: <korolev.yv@oit.int>
- Telegram: @your_nick (замените на актуальный)
- Issues: через GitHub Issues
